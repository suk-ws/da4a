package cc.sukazyo.std
package event

import contexts.GivenContext
import datetime.DateTimeTypeAliases.EpochMillis
import stacks.WithCurrentStack

import scala.collection.mutable

/** Context of current emitted event.
  *
  * Once an event is emitted, a new [[EventContext]] will be generated, and will be passed to
  * all the listeners that can access to the context.
  * For once emitted event, the [[EventContext]] is unique and will be shared by all the
  * listeners.
  * By using the context, listeners can share data and status between each other, like check
  * if the event is processed by previous listeners.
  *
  * Notice that only event that implemented [[AbstractRichEvent]] uses the context, some simple
  * events may not have the context.
  *
  * @since 0.2.0
  * 
  * @tparam EP The event's parameter type.
  *
  *            For one emitted event, the parameters of this event will be stored into
  *            [[EventContext.params]] in the EventContext.
  *            By receiving the EventContext, all the listeners are able to access to the
  *            parameters.
  */
trait EventContext [+EP] {
	
	/** Parameters of this event, provided by the event emitter.
	  *
	  * The params here are the original objects that the event emitter provided when emitting
	  * the event, not the copy.
	  * So if the params are mutable, the listeners can modify the
	  * params directly, and may produce unexpected effects to subsequence listeners or the
	  * whole program.
	  * Be aware of generating side effects to the params.
	  *
	  * @since 0.2.0
	  */
	val params: EP
	
	/** Stores all the history status of current emitted event.
	  *
	  * Can get by method [[status]].
	  * The more complex description can be found there.
	  *
	  * @since 0.2.0
	  */
	private val _status: mutable.ListBuffer[EventStatus] = mutable.ListBuffer.empty
	
	/** [[GivenContext]] that associated with the event.
	  *
	  * Can be used to store and share objects between event listeners.
	  *
	  * See [[GivenContext]] for more information.
	  *
	  * @since 0.2.0
	  */
	val givenCxt: GivenContext = GivenContext()
	
	/** The [[EpochMillis]] datetime when current event is emitted, and current [[EventContext]]
	  * is created.
	  *
	  * @since 0.2.0
	  */
	val timeStartup: EpochMillis = System.currentTimeMillis
	
	/** If this event is processed.
	  *
	  * It checks the last event status (using method [[state]] or [[stateOption]]), when the
	  * latest event status matches the following types, the event is considered as processed:
	  *
	  * - [[EventStatus.Success]]
	  * - [[EventStatus.Cancelled]]
	  *
	  * For most listeners, if the event is considered processed (meanwhile, this method returns
	  * `true`), the listener will be skipped.
	  * You can customize listener's [[EventListener.isSkipEvent]] method to customize the
	  * behavior.
	  *
	  * @since 0.2.0
	  *
	  * @return `true` if the event has been considered processed, or precisely is that the
	  *         last event status is the implementation of [[EventStatus.Success]] or
	  *         [[EventStatus.Cancelled]].
	  *
	  *         `false` otherwise.
	  */
	def isEventOk: Boolean =
		stateOption match
			case Some(state) =>
				if (
					state.isInstanceOf[EventStatus.Success] ||
					state.isInstanceOf[EventStatus.Cancelled]
				) true
				else false
			case None => false
	
	/** todo: docs
	  * @since 0.2.0
	  * 
	  * @param state
	  */
	def pushEventState (state: EventStatus): Unit =
		_status += state
	
	/** Set the event status to [[EventStatus.OK]].
	  *
	  * This will push a new [[EventStatus.OK]] to the status list.
	  * 
	  * todo: docs refactor
	  * @since 0.2.0
	  */
	//noinspection UnitMethodIsParameterless
	def setEventOk: Unit =
		pushEventState(EventStatus.Success(WithCurrentStack.getStackHeadBeforeClass[EventContext[EP]]))
	
	/** Set the event status to [[EventStatus.CANCELED]].
	  *
	  * This will push a new [[EventStatus.CANCELED]] to the status list.
	  * 
	  * todo: docs refactor
	  * @since 0.2.0
	  */
	//noinspection UnitMethodIsParameterless
	def setEventCanceled: Unit =
		pushEventState(EventStatus.Cancelled(WithCurrentStack.getStackHeadBeforeClass[EventContext[EP]]))
	
	/** Get the last [[EventStatus]] of current emitted event.
	  *
	  * For more complex description for a emitted event status, see [[status]].
	  *
	  * For this method, what it returns is just the [[EventStatus]] that generated by the last
	  * [[pushEventState]] (or [[setEventOk]], [[setEventCanceled]]) call.
	  *
	  * Comparing with `status.last`, this method is faster (due to this does not create list
	  * copy), and does not generate an exception when the status list is empty, but returns
	  * `null`.
	  *
	  * @since 0.2.0
	  *
	  * @return A [[EventStatus]] that in the last of status history.
	  *
	  *         Or `null` if there is no status yet.
	  */
	def state: EventStatus | Null =
		stateOption match
			case Some(x) => x
			case None => null
	
	/** Get the last [[EventStatus]] of current emitted event.
	  *
	  * Same with [[state]], but returns an [[Option]] instead of returning possibly `null`.
	  *
	  * More likely the same with `status.lastOption`.
	  * Same with [[state]], this method doesn't create list copy thus faster that [[status]].
	  *
	  * @since 0.2.0
	  * 
	  * @return An [[Option]] of [[EventStatus]] that in the last of status history.
	  *         
	  *         If no status yet, the Option will be [[None]].
	  */
	def stateOption: Option[EventStatus] =
		_status.lastOption
	
	/** Get all the history [[EventStatus]] of current emitted event.
	  *
	  * The status of an emitted event is stored in a list.
	  * It is like a stack, the earlier status is at the start of the list, and the latest
	  * status is at the end of the list.
	  * Unlike a stack, the status list can only be appended, and can't be popped.
	  *
	  * Using [[List.head]] to get the most early status, and [[List.last]] to get the latest
	  * status (be aware the cases that the list might be empty).
	  *
	  * In the beginning, the status list is empty, in most cases, that means this event is not
	  * completely processed by any listeners yet, and can be safely processed by the
	  * subsequence listeners.
	  * Due to it might be empty, the [[List.head]] ([[List.last]]) might throw an exception if
	  * the status list is empty, use [[List.headOption]] ([[List.lastOption]]) can be safer,
	  * or check [[List.isEmpty]] manually.
	  *
	  * Every event listener can push a new status (or multiple new status) by calling method
	  * [[pushEventState]] (or shortcuts method [[setEventOk]] and [[setEventCanceled]]).
	  * For what these methods do, see their documentation.
	  *
	  * This method returns an immutable copy of the status history (the original is mutable).
	  *
	  * For most cases, you may only care the latest event status, use [[state]] or
	  * [[stateOption]] is enough (those don't need a list copy, so faster).
	  *
	  * @since 0.2.0
	  */
	def status: List[EventStatus] =
		_status.toList
	
}

/** Factory of [[EventContext]].
  *
  * @since 0.2.0
  */
object EventContext {
	
	/** Create a new [[EventContext]] with the given emitted event's parameters.
	  *
	  * This method is meant to be used by the event manager's internal implementation.
	  * Listeners should always receive a [[EventListener]] from event manager instead of
	  * creating a new one.
	  *
	  * @since 0.2.0
	  * 
	  * @param _params parameters of the current emitted event.
	  * @tparam EP The event's parameter type.
	  * @return A new [[EventContext]], stored the emitted event parameters, and the creation
	  *         time of itself.
	  */
	def apply [EP] (_params: EP): EventContext[EP] = new EventContext[EP] {
		override val params: EP = _params
	}
	
}
